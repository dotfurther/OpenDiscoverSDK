<!DOCTYPE html ><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" href="../css/bulma.css" /><link rel="stylesheet" href="../css/font-awesome.min.css" /><link rel="stylesheet" href="../css/presentationStyle.css" /><link rel="stylesheet" href="../css/vs.min.css" /><script src="../scripts/jquery-3.5.1.min.js"></script><script src="../scripts/clipboard.min.js"></script><script src="../scripts/highlight.min.js"></script><script src="../scripts/presentationStyle.js"></script><title>Extract Content using the SDK ContentExtractorFactory</title><meta name="Title" content="Extract Content using the SDK ContentExtractorFactory" /><meta name="Help.Id" content="71d4234a-21a7-48a5-9d83-d1b8a2ed4250" /><meta name="Help.ContentType" content="Concepts" /><meta name="guid" content="71d4234a-21a7-48a5-9d83-d1b8a2ed4250" /><meta name="Description" content="This topic and sub-topics show how to use the Open Discover SDK content extractor factory pattern to extract content from documents and items from archives and mail store containers." /><meta name="tocFile" content="../toc/IDB.xml" /></head><body><div class="fixedLayout"><div id="Header" class="fixedHeader"><div class="pageHeader level mb-0 py-2 px-4"><div id="TitleContainer" class="level-left"><div id="DocumentationTitle" class="level-item">Open Discover® SDK and Platform for .NET - Release 2025.4.2</div></div><div id="LangFilterSearchContainer" class="level-right"><div class="level-item"><div class="dropdown is-hoverable"><div class="dropdown-trigger"><button class="button" aria-haspopup="true" aria-controls="dropdown-menu"><span id="CurrentLanguage"></span><span class="icon is-small"><i class="fa fa-angle-down" aria-hidden="true"></i></span></button></div><div class="dropdown-menu" role="menu"><div id="LanguageSelections" class="dropdown-content"><a class="dropdown-item languageFilterItem" data-languageId="cs">C#</a></div></div></div></div><div class="level-item"><form id="SearchForm" action="#" onsubmit="TransferToSearchPage(); return false;"><div class="field"><div class="control has-icons-left"><input id="SearchTerms" class="input" type="text" maxlength="200" placeholder="Search" /><span class="icon is-small is-left"><i class="fa fa-search"></i></span><button id="SearchButton" type="submit" class="is-hidden"></button></div></div></form></div></div></div></div><div class="fixedContent"><nav class="breadcrumb my-1 px-2 border-bottom" role="navigation"><ul id="TopicBreadcrumbs" /></nav><div id="ContentContainer" class="columns pl-5 pr-5 fixedContent"><div id="ShowHideTOCColumn" class="column is-hidden-tablet"><a id="ShowHideTOC">Show/Hide TOC</a></div><div id="TOCColumn" class="column is-hidden-mobile"><nav class="toc"><ul id="TableOfContents" class="toc-menu" /></nav></div><div id="Resizer" class="is-hidden"></div><div id="TopicContent" class="column content is-7"><h1>Extract Content using the SDK ContentExtractorFactory</h1><div><p>
      This topic and sub-topics show how to use the Open Discover SDK content extractor factory pattern to extract content from documents and items from 
      archives and mail store containers.
      </p><article class="message is-warning"><div class="message-header"><p><span class="icon"><i class="fa fa-warning"></i></span>  Important</p></div><div class="message-body"><p>
        The .NET assemblies that make up Open Discover SDK are x64 release builds (not AnyCPU) due to x64 dependencies. Therefore, applications that
        reference and use the SDK assemblies MUST also be x64 builds.</p></div></article></div><div id="IDCABSection" class="noTitle"><p>
        The steps to extract document content or to extract items from archive or mail store containers: 
        </p><ol><li>
          Identify the document's file format using one of the overloaded <a href="5c18f0cf-0ec5-aff9-10b8-e2c62ac74a73.htm">DocumentIdentifier</a>.Identify methods.
          </li><li>
          Use method <a href="2fbf109b-c0df-5cb9-abc9-e22bc3957c16.htm">ContentExtractorFactory</a>.GetContentExtractor to get an <a href="099ca015-0381-74ac-fed4-082901e8f959.htm">ContentExtractorResult</a> 
          object for the specific file format identified in step (1) above.
          </li><li>
          Use the <a href="e34c8f80-a415-2275-2f2e-74e78119de93.htm">ContentExtractor</a> property of the returned ContentExtractorResult object in step (2) above to 
          get the base <a href="94fa03c2-ad71-ecdc-48b0-48fb7ff40e45.htm">IContentExtractor</a> extractor interface.
          </li><li>
          Use the IContentExtractor object's <a href="7e5a4e4e-e9b6-73cc-6a6a-55a3c97ed0f7.htm">ContentExtractorType</a> property to 
          determine the type of the IContentExtractor derived interface that is specific to extracting content for the file format.
          </li><li>
          Type-cast the base IContentExtractor interface to the specific derived IContentExtractor interface and use that interface to extract the desired content.
          </li></ol><p /><article class="message is-info"><div class="message-header"><p><span class="icon"><i class="fa fa-info-circle"></i></span>  Note</p></div><div class="message-body"><p>
          Method <a href="2fbf109b-c0df-5cb9-abc9-e22bc3957c16.htm">ContentExtractorFactory</a>.GetContentExtractor takes a <a href="b65f5ca9-d476-8b01-b6d2-c47f988ba0a2.htm">ContentExtractionSettings</a> object as an argument. 
          The ContentExtractorSettings class determines what content is extracted, determines whether hashes are calculated, if extracted text has languages in text identified, and more.
          </p></div></article><p>
        The following are all of the IContentExtractor derived interfaces:
        </p><ul><li><a href="fc555ced-4e25-4a75-d7eb-c52c1ad0fd37.htm">IDocumentContentExtractor</a> - returned for supported non-container documents such as 
          office documents, emails, PDFs, HTML, XML, multimedia, raster images, vector images, etc.
          </li><li><a href="9d2fb8da-9eff-b1d9-e027-a4b2d24993e8.htm">IArchiveExtractor</a> - returned for supported archive container types such as 
          7ZIP, ZIP, RAR, TAR, GZIP, etc.
          </li><li><a href="b6b002d9-7dfa-acce-2221-db203d4ffcfa.htm">IMailStoreExtractor</a> - returned for supported mail store container types such as 
          PST, OST, MBOX, etc.
          </li><li><a href="72878ee2-8469-dfe5-15b3-d1f3c9fb8ed8.htm">IDatabaseExtractor</a> - returned for supported database file types, currently  
          only Microsoft Access database is supported by this interface.
          </li><li><a href="075a32e0-700d-6ca2-6d30-a16994b8b27a.htm">IDocumentStoreExtractor</a> - returned for supported document store container types, currently  
          only Domino DXL document database export file (an XML database of documents) is supported by this interface.
          </li><li><a href="425bbcf3-95b6-7564-9777-41f0c39bb9b7.htm">IUnsupportedExtractor</a> - returned for unsupported document formats if 
          <a href="d2e304cb-8803-14fc-d7a8-09c27365c6a0.htm">UnsupportedFiltering</a> is true. This interface allows 
          for binary-to-text filtering on unsupported formats.  
          </li><li><a href="15fe76f2-d9da-2d1d-0fde-5751a490457f.htm">ILargeUnsupportedExtractor</a> - returned for "large" unsupported document formats. "Large" is 
          defined by property <a href="90aee97f-a132-9d0b-5c91-d6ac2eb95ace.htm">LargeDocumentCritera</a>. This interface 
          allows for binary-text filtering of very large files but writes the filtered text (which can be very large) to a System.IO.FileStream object instead setting the 
          <a href="72ac3b45-72b3-56b8-7864-53f0d59552f4.htm">ExtractedText</a> property (in-memory string) with extracted text. See also 
          <a href="d2e304cb-8803-14fc-d7a8-09c27365c6a0.htm">UnsupportedFiltering</a>.
          </li><li><a href="12e90c5d-c0eb-b570-10bb-3626709715dd.htm">ILargeEncodedTextExtractor</a> - returned for "large" encoded text documents (e.g., large CSV formatted files). 
          "Large" is defined by property <a href="90aee97f-a132-9d0b-5c91-d6ac2eb95ace.htm">LargeDocumentCritera</a>. This interface is only useful 
          if encoded text file is not in an easily indexed encoding like UTF-8 or UTF-16. The extracted text, which is written to a System.IO.FileStream object instead of setting the 
          <a href="72ac3b45-72b3-56b8-7864-53f0d59552f4.htm">ExtractedText</a> property (in-memory string), is automatically written in UTF-8 or 
          UTF-16 encodings. See property <a href="e703d60d-4cc3-b9ae-58df-0a913e95be3e.htm">UseLargeDocumentUTF16Encoding</a>.
          </li></ul><p /><p>
        Diagram of the IContentExtractor derived interfaces:
        </p><figure class="mediaNear"><img alt="IContent Extractor Diagram" src="../media/IContentExtractorDiagram.png" /></figure><p>
        The following example shows the pattern of how to get the specific IContentExtractor derived interfaces. How to use the specific derived interfaces is discussed in 
        this section's sub-topics.
        </p><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">Document Content Extraction Pattern</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codeWithNumbers"><div class="lineNumbers"><pre xml:space="preserve">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91</pre></div><div class="codePanel hljs numbered"><pre xml:space="preserve"><code class="language-cs">var settings = new ContentExtractionSettings();
settings.CalculateBinaryHash        = true; // Calculate binary hashes
settings.CalculateContentHash       = true; // Calculate content hashes on supported formats such as emails and Office documents
settings.ExtractEmbeddedDocuments   = true; // Extract attachments\embedded documents
settings.ExtractOfficeEmbeddedMedia = true; // Extract embedded media for Office formats
settings.ExtractionType             = ContentExtractionType.TextAndMetadata; // We want text and metadata extracted

using (var stream = File.OpenRead(filePath))
{
    //========================================================================================
    // Step 1 - Identify document file format:
    //========================================================================================
    var docIdResult = DocumentIdentifier.Identify(stream, filePath);

    //========================================================================================
    // Step 2 - Get the content extractor result for the file format:
    //========================================================================================
    var contentExtractorResult = ContentExtractorFactory.GetContentExtractor(stream, docIdResult, filePath, settings);

    if (contentExtractorResult.HasError)
    {
        LogErrorMessage(string.Format("Error getting content extractor for file ID {0}: {1}", docIdResult.ID, contentExtractorResult.Error));
    }
    else
    {
        //========================================================================================
        // Step 3 - Get the specific IContentExtractor derived interface for the file format:
        //========================================================================================
        var extractorType = contentExtractorResult.ContentExtractor.ContentExtractorType;

        switch (extractorType)
        {
            case ContentExtractorType.Archive:
                {
                    var archiveExtractor = (IArchiveExtractor)contentExtractorResult.ContentExtractor;
                    // TODO: Following help topics will show how to use this interface
                }
                break;
            case ContentExtractorType.Document:
                {
                    var docExtractor = ((IDocumentContentExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: Following help topics will show how to use this interface
                }
                break;
            case ContentExtractorType.MailStore:
                {
                    var mailStoreExtractor = ((IMailStoreExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: Following help topics will show how to use this interface
                }
                break;
            case ContentExtractorType.Database:
                {
                    var databaseExtractor = ((IDatabaseExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: Following help topics will show how to use this interface
                }
                break;                            
            case ContentExtractorType.DocumentStore:
                {
                    var docStoreExtractor = ((IDocumentStoreExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: Following help topics will show how to use this interface
                }
                break;
            case ContentExtractorType.Unsupported:
                {
                    // Binary-to-text extraction: Note, if property ContentExtractionSettings.BinaryToTextOnUnsupportedTypes is false, then calling
                    //                            IUnsupportedExtractor.ExtractContent will only calculate binary hashes without performing binary-to-text filtering.
                    //                            Binary-to-text is not useful for file formats (e.g., Id.MPEG1ElementaryStream) that do not have any textual
                    //                            content. It is up to the user to filter these formats out using either file format Id or file format classification.
                    var bin2TextExtractor = ((IUnsupportedExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: Following help topics will show how to use this interface
                }
                break;
            case ContentExtractorType.LargeUnsupported:
                {
                    // Binary-to-text extraction - we extract to a memory stream here but user should extract to a file stream for the cases
                    //                             of very 'large' binary documents - because the filtered text could get into the gigabytes
                    //                             depending on the BLOB size and content.
                    var largeDocBin2TextExtractor = ((ILargeUnsupportedExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: Following help topics will show how to use this interface
                }
                break;
            case ContentExtractorType.LargeEncodedText:
                {
                    // "large" encoded text file extraction 
                    var largeEncodedTextExtractor = ((ILargeEncodedTextExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: Following help topics will show how to use this interface
                }
                break;
        }
    }
}</code></pre></div></div></div></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>See Also</h2><div id="seeAlsoSection"><h4 class="quickLinkHeader">Concepts</h4><div><a href="8e0c8470-7ad9-4dae-95fb-7a9eb05b78f1.htm">How to use the IDocumentContentExtractor Interface</a></div><div><a href="065d43df-6ccd-4692-a2b2-0f114a52848b.htm">How to use the IArchiveExtractor Interface</a></div><div><a href="91048e30-0b6e-476f-986d-f5f56b7a5525.htm">How to use the IDatabaseExtractor Interface</a></div><div><a href="6d85e229-353b-4ec3-8ede-5710273d1cf5.htm">How to use the IMailStoreExtractor Interface</a></div><div><a href="a2cbea0a-2486-40fb-8c08-2db0b8f5ee27.htm">How to use the IDocumentStoreExtractor Interface</a></div><div><a href="e0906c8e-d500-4c1f-af0c-7ea7e407b53e.htm">How to use the IUnsupportedExtractor Interface</a></div><div><a href="113aee0b-e0dd-4667-91de-3f82c0c96636.htm">How to use the ILargeUnsupportedExtractor Interface</a></div><div><a href="b789bdbc-1f4a-4642-93da-86e218036e8f.htm">How to use the ILargeEncodedTextExtractor Interface</a></div><h4 class="quickLinkHeader">Other Resources</h4><div><a href="https://github.com/dotfurther/OpenDiscoverSDK" target="_blank" rel="noopener noreferrer">OpenDiscoverSDK Samples Repository on GitHub</a></div></div></div><div id="InThisArticleColumn" class="column is-hidden-mobile"><nav class="menu sticky is-hidden"><p class="menu-label"><strong>In This Article</strong></p><ul id="InThisArticleMenu" class="menu-list"><li><a class="quickLink">See Also</a><ul class="menu"><li><a class="quickLink">Concepts</a></li><li><a class="quickLink">Other Resources</a></li></ul></li></ul></nav></div></div></div><footer id="PageFooter" class="footer border-top py-3 fixedFooter"><div class="columns"><div class="column"><p>Copyright © 2017-2025 dotFurther, inc. All rights reserved.  "Open Discover" is a registered trademark (®) of dotFurther, inc.</p><div class="feedbackLink">Send comments on this topic to
        <a id="HT_MailLink" href="mailto:support%40dotfurther.com?Subject=Open%20Discover®%20SDK%20and%20Platform%20for%20.NET%20-%20Release%202025.4.2">support@dotfurther.com</a></div>
        <script type="text/javascript">
        var HT_mailLink = document.getElementById("HT_MailLink");
        HT_mailLink.href += ": " + document.title + "\u0026body=" + encodeURIComponent("Your feedback is used to improve the documentation and the product. Your e-mail address will not be used for any other purpose and is disposed of after the issue you report is resolved. While working to resolve the issue that you report, you may be contacted via e-mail to get further details or clarification on the feedback you sent. After the issue you report has been addressed, you may receive an e-mail to let you know that your feedback has been addressed.");
        </script> 
				</div><div class="column"> 
				</div></div></footer></div><script>$(function(){
SetDefaultLanguage("cs");
LoadTocFile(null, null);
InitializeQuickLinks();

$(".toggleSection" ).click(function () {
    SectionExpandCollapse(this);
});

$(".toggleSection").keypress(function () {
    SectionExpandCollapseCheckKey(this, event)
});
hljs.highlightAll();
});</script></body></html>