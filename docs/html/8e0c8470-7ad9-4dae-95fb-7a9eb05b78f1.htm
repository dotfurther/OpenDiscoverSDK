<!DOCTYPE html ><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" href="../css/bulma.css" /><link rel="stylesheet" href="../css/font-awesome.min.css" /><link rel="stylesheet" href="../css/presentationStyle.css" /><link rel="stylesheet" href="../css/vs.min.css" /><script src="../scripts/jquery-3.5.1.min.js"></script><script src="../scripts/clipboard.min.js"></script><script src="../scripts/highlight.min.js"></script><script src="../scripts/presentationStyle.js"></script><title>How to use the IDocumentContentExtractor Interface</title><meta name="Title" content="How to use the IDocumentContentExtractor Interface" /><meta name="Help.Id" content="8e0c8470-7ad9-4dae-95fb-7a9eb05b78f1" /><meta name="Help.ContentType" content="Concepts" /><meta name="guid" content="8e0c8470-7ad9-4dae-95fb-7a9eb05b78f1" /><meta name="Description" content="The section shows how to use the IDocumentContentExtractor interface. This interface is used to extract content from office documents, emails, PDFs, HTML files, raster images, multimedia files, and vector images." /><meta name="tocFile" content="../toc/IDBB.xml" /></head><body><div class="fixedLayout"><div id="Header" class="fixedHeader"><div class="pageHeader level mb-0 py-2 px-4"><div id="TitleContainer" class="level-left"><div id="DocumentationTitle" class="level-item">Open Discover® SDK and Platform for .NET - Release 2025.4.2</div></div><div id="LangFilterSearchContainer" class="level-right"><div class="level-item"><div class="dropdown is-hoverable"><div class="dropdown-trigger"><button class="button" aria-haspopup="true" aria-controls="dropdown-menu"><span id="CurrentLanguage"></span><span class="icon is-small"><i class="fa fa-angle-down" aria-hidden="true"></i></span></button></div><div class="dropdown-menu" role="menu"><div id="LanguageSelections" class="dropdown-content"><a class="dropdown-item languageFilterItem" data-languageId="cs">C#</a></div></div></div></div><div class="level-item"><form id="SearchForm" action="#" onsubmit="TransferToSearchPage(); return false;"><div class="field"><div class="control has-icons-left"><input id="SearchTerms" class="input" type="text" maxlength="200" placeholder="Search" /><span class="icon is-small is-left"><i class="fa fa-search"></i></span><button id="SearchButton" type="submit" class="is-hidden"></button></div></div></form></div></div></div></div><div class="fixedContent"><nav class="breadcrumb my-1 px-2 border-bottom" role="navigation"><ul id="TopicBreadcrumbs" /></nav><div id="ContentContainer" class="columns pl-5 pr-5 fixedContent"><div id="ShowHideTOCColumn" class="column is-hidden-tablet"><a id="ShowHideTOC">Show/Hide TOC</a></div><div id="TOCColumn" class="column is-hidden-mobile"><nav class="toc"><ul id="TableOfContents" class="toc-menu" /></nav></div><div id="Resizer" class="is-hidden"></div><div id="TopicContent" class="column content is-7"><h1>How to use the IDocumentContentExtractor Interface</h1><div><p>
      The section shows how to use the IDocumentContentExtractor interface. This interface is used to extract content from office documents, emails, PDFs, HTML files,
      raster images, multimedia files, and vector images.
      The section also shows how to decrypt file formats that are supported for decryption through example.
      </p></div><div id="IDBABSection" class="noTitle"><p>
        The <a href="fc555ced-4e25-4a75-d7eb-c52c1ad0fd37.htm">IDocumentContentExtractor</a> interface has one method used to extract 
        document content:   <span class="code">DocumentContent ExtractContent(string password = null)</span></p><p>
        The password is optional and is used to decrypt supported types for decryption such as Microsoft Word, Excel, PowerPoint, PDF, and OpenDocument formats. 
        </p><p>
        The following example shows how to use IDocumentContentExtractor interface to extract content from a password encrypted document by prompting 
        the user to enter a password via a dialog box. Optionally, if user knows the passwords of the documents they are going to process the user can set
        up a password list to cycle through instead of prompting via a dialog box.
        </p><article class="message is-info"><div class="message-header"><p><span class="icon"><i class="fa fa-info-circle"></i></span>  Note</p></div><div class="message-body"><p>
          Attempting to decrypt a document with a password is an expensive operation by design. This SDK is not optimized to be a password cracker and should not be used as one. 
          Any password lists to cycle through when encountering documents should only contain known passwords that decrypt the password encrypted documents being processed.
          </p></div></article><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">IDocumentContentExtractor Interface Usage</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codeWithNumbers"><div class="lineNumbers"><pre xml:space="preserve">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140</pre></div><div class="codePanel hljs numbered"><pre xml:space="preserve"><code class="language-cs">var settings = new ContentExtractionSettings();
settings.CalculateBinaryHash        = true; // Calculate binary hashes
settings.CalculateContentHash       = true; // Calculate content hashes on supported formats such as emails and Office documents
settings.ExtractEmbeddedDocuments   = true; // Extract attachments\embedded documents
settings.ExtractOfficeEmbeddedMedia = true; // Extract embedded media for Office formats
settings.ExtractionType             = ContentExtractionType.TextAndMetadata; // We want text and metadata extracted

using (var stream = File.OpenRead(filePath))
{
    //========================================================================================
    // Step 1 - Identify document file format:
    //========================================================================================
    var docIdResult = DocumentIdentifier.Identify(stream, filePath);

    //========================================================================================
    // Step 2 - Get the content extractor result for the file format:
    //========================================================================================
    var contentExtractorResult = ContentExtractorFactory.GetContentExtractor(stream, docIdResult, filePath, settings);

    if (contentExtractorResult.HasError)
    {
        LogErrorMessage(string.Format("Error getting content extractor for file ID {0}: {1}", docIdResult.ID, contentExtractorResult.Error));
    }
    else
    {
        //========================================================================================
        // Step 3 - Get the specific IContentExtractor derived interface for the file format:
        //========================================================================================
        var extractorType = contentExtractorResult.ContentExtractor.ContentExtractorType;

        switch (extractorType)
        {
              case ContentExtractorType.Document:
                  {
                    // The "ContentExtractorType.Document" extractor type indicates the IDocumentContentExtractor interface is to be used
                    var docExtractor = ((IDocumentContentExtractor)contentExtractorResult.ContentExtractor);
                    var docContent   = docExtractor.ExtractContent();

                    // Password cycling for supported encrypted documents: 
                    //  - DocumentContent.Result = ContentResult.WrongPassword, indicating wrong password, because on 1st call to ExtractContent
                    //    method above we passed in null (default value) and this document is encrypted
                    //  - User can also set up a password list of known passwords to cycle through when encountering encrypted documents.
                    //  - Check if "docExtractor.SupportsDecryption" is true, if true then this format supports decryption
                    if (docContent.Result == ContentResult.WrongPassword &amp;&amp; docContent.IsEncrypted &amp;&amp; docExtractor.SupportsDecryption)
                    {
                        RETRY_DOC_PASSWORD:;

                        var passwordDialog = new PasswordForm();

                        if (passwordDialog.ShowDialog() == DialogResult.OK)
                        {
                            // Try the user entered password:
                            docContent = ((IDocumentContentExtractor)contentExtractorResult.ContentExtractor).ExtractContent(passwordDialog.Password);

                            if (docContent.Result == ContentResult.WrongPassword)
                            {
                                goto RETRY_DOC_PASSWORD;
                            }
                        }
                    }

                    if (docContent.Result == ContentResult.Ok)
                    {       
                        // Success - Do something with extracted content, for example use Lucene.NET to index the text and index the metadata as fields

                        //
                        // Check for special document content classes that derive from DocumentContent class and
                        // have extra content extracted:
                        //
                        if (docContent is EmailDocumentContent)
                        {
                           var emailDocContent = (EmailDocumentContent)docContent;
                           // Do something we extra email related content...
                        }
                        else if (docContent is HtmlDocumentContent)
                        {
                           var htmlDocContent = (HtmlDocumentContent)docContent;
                           // Do something we extra HTML related content... the extra HTML related content such as HyperLinks property
                           // can be used for web-crawling a website
                        }
                        else if (docContent is PdfDocumentContent)
                        {
                           var pdfDocContent = (PdfDocumentContent)docContent;
                           // Do something we extra PDF related content...
                        }                                    
                    }
                    else
                    {
                       // Some level of Error - Documents that have an error often times still have some content extracted such as metadata, 
                       // attachments, or text (there are fallback text extraction procedures for some formats and/or binary-text filtering 
                       // can be used to extract useful text in a lot of cases)
                    }
                }
                break;

            case ContentExtractorType.Archive:
                {
                    var archiveExtractor = ((IArchiveExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: A different help topic will show how to use this interface
                }
                break;
            case ContentExtractorType.MailStore:
                {
                    var mailStoreExtractor = ((IMailStoreExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: A different help topic will show how to use this interface
                }
                break;
            case ContentExtractorType.Database:
                {
                    var databaseExtractor = ((IDatabaseExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: A different help topic will show how to use this interface
                }
                break;                            
            case ContentExtractorType.DocumentStore:
                {
                    var docStoreExtractor = ((IDocumentContentExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: A different help topic will show how to use this interface
                }
                break;
            case ContentExtractorType.Unsupported:
                {
                    var bin2TextExtractor = ((IUnsupportedExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: A different help topic will show how to use this interface
                }
                break;
            case ContentExtractorType.LargeUnsupported:
                {
                    var largeDocBin2TextExtractor = ((ILargeUnsupportedExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: A different help topic will show how to use this interface
                }
                break;
            case ContentExtractorType.LargeEncodedText:
                {
                    var largeEncodedTextExtractor = ((ILargeEncodedTextExtractor)contentExtractorResult.ContentExtractor);
                    // TODO: A different help topic will show how to use this interface
                }
                break;
        }
    }
}</code></pre></div></div></div><p>
        The following unit test example code illustrates the various document content extracted like text, metadata, attachments, hashes, and languages identified in the 
        extracted text:
        </p><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">Email Document</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codeWithNumbers"><div class="lineNumbers"><pre xml:space="preserve">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92</pre></div><div class="codePanel hljs numbered"><pre xml:space="preserve"><code class="language-cs">[TestMethod]
public void OutlookMsgTextAndMetadataTest()
{
    var settings = new ContentExtractionSettings();
    settings.CalculateBinaryHash        = true;
    settings.CalculateContentHash       = true;
    settings.ShowUtcOffsetForTimeText   = true;
    settings.ExtractEmbeddedDocuments   = false;
    settings.ExtractOfficeEmbeddedMedia = false;
    settings.CollectionTimeZone = TimeZoneInfo.Utc;
    settings.ExtractionType     = ContentExtractionType.TextAndMetadata;

    var file        = Path.Combine(_testFilesBasePath, @"Deduplication\Email", "test.msg");
    var sentDateUtc = new DateTime(2007, 1, 5, 0, 16, 11, DateTimeKind.Utc);

    using (var stream = File.OpenRead(file))
    {
        var idResult        = DocumentIdentifier.Identify(stream, file);
        var extractorResult = ContentExtractorFactory.GetContentExtractor(stream, idResult, file, settings);

        var extractorType = extractorResult.ContentExtractor.ContentExtractorType;
        Assert.IsTrue(extractorType == ContentExtractorType.Document);

        var docExtractor = ((IDocumentContentExtractor)extractorResult.ContentExtractor);
        var docContent   = docExtractor.ExtractContent();

        // Assert that the DocumentContent object is an email type and is safe to type-cast to EmailDocumentContent:
        Assert.IsTrue(docContent.IsEmailType);
        var emailContent = docContent as EmailDocumentContent;

        Assert.IsTrue(emailContent.Result == ContentResult.Ok);

        Assert.IsTrue(emailContent.FormatId.ID == Id.OutlookMessage);
        Assert.IsTrue(emailContent.ExtractedText.StartsWith("From: dummy &lt;dummy@fake.org&gt;"));
        Assert.IsTrue(emailContent.ExtractedText.IndexOf("Subject: RE: Party") &gt; 0);
        Assert.IsTrue(emailContent.ExtractedText.IndexOf("Are you going to the party?") &gt; 0);

        Assert.IsTrue(emailContent.ChildDocuments.Count   == 1);
        Assert.IsTrue(emailContent.ChildDocuments[0].Name == "directions.doc");

        Assert.IsTrue(emailContent.MD5BinaryHash      == "471B0C2443F2B2E610B6BF905480DEF5");
        Assert.IsTrue(emailContent.SHA1BinaryHash     == "86EF0955E35A6BDBF003BE813FBF0395B6D7546F");
        // Email types support content hash, the content hash aides in de-duplicating the same email whether they are saved 
        // as .msg, .eml, or .emlx formats. If you save an .eml message as an .msg using Outlook, these 2 files will have
        // different binary hashes due to different bytes in files. However, the content hash most likely will be the same
        // for both files.
        Assert.IsTrue(emailContent.MD5ContentHash     == "2F780AEA9DD7930439B340FFBC660A53");
        Assert.IsTrue(emailContent.SHA1ContentHash    == "EE6B61C9BAEBC87D6F5D2CB33B65EEA9B0F5C3E2");
        // Email types have extra hashes calculated:
        Assert.IsTrue(emailContent.Sha1HeaderHash     == "806A056F8F7BAD3FAE31A226B26EE1E3653AF423");
        Assert.IsTrue(emailContent.Sha1BodyHash       == "6F38C846E0E468732FBCA8CCB9EDDE131A1501A6");
        Assert.IsTrue(emailContent.Sha1RecipientsHash == "D8FE882FC2E8AE88D0504D58BBF324C7677BCD8B");

        Assert.IsTrue(emailContent.Subject == "RE: Party");

        Assert.IsTrue(emailContent.Sender != null);
        Assert.IsTrue(emailContent.Sender.Name        == "dummy");
        Assert.IsTrue(emailContent.Sender.AddressType == EmailAddressType.Sender);
        Assert.IsTrue(emailContent.Sender.SmtpAddress == "dummy@fake.org");
        Assert.IsTrue(emailContent.Sender.X500DN      == string.Empty);

        Assert.IsTrue(emailContent.From        != null);
        Assert.IsTrue(emailContent.From.Count  == 1);
        Assert.IsTrue(emailContent.Sender.Name == emailContent.From[0].Name);
        Assert.IsTrue(emailContent.From[0].AddressType == EmailAddressType.From);
        Assert.IsTrue(emailContent.Sender.SmtpAddress  == emailContent.From[0].SmtpAddress);
        Assert.IsTrue(emailContent.From[0].X500DN      == null);
        Assert.IsTrue(emailContent.SentDate.Value.CompareTo(sentDateUtc) == 0);

        Assert.IsTrue(emailContent.HasHtmlBody);
        Assert.IsTrue(emailContent.HasTextBody);
        Assert.IsTrue(emailContent.HasRtfBody);
        Assert.IsTrue(emailContent.BodyType  == EmailBodyType.RtfEncapsulatedHTML); // HTML body originated from RTF body(was encapsulated in RTF body)
        Assert.IsTrue(emailContent.MessageId == "&lt;1234567892423424242.fake.org&gt;");

        // Extracted text language identification results:
        Assert.IsTrue(emailContent.LanguageIdResults != null);
        Assert.IsTrue(emailContent.LanguageIdResults.Count == 1);
        Assert.IsTrue(emailContent.LanguageIdResults[0].LangIso639 == "en"); // English

        Assert.IsTrue(emailContent.Metadata.Count == 34); // 34 email metadata fields extracted in total

        // We use "known" string and datetime metadata helper classes for the metadata field names (in this test it is known that these fields exist 
        // in the test file):
        Assert.IsTrue(((StringProperty)emailContent.Metadata[KnownStringMetadataFields.From]).Value       == "dummy &lt;dummy@fake.org&gt;");
        Assert.IsTrue(((StringProperty)emailContent.Metadata[KnownStringMetadataFields.SenderName]).Value == "dummy");
        Assert.IsTrue(((StringProperty)emailContent.Metadata[KnownStringMetadataFields.SentRepresentingName]).Value == "dummy");
        Assert.IsTrue(((StringProperty)emailContent.Metadata[KnownStringMetadataFields.SenderSmtpAddress]).Value    == "dummy@fake.org");
        Assert.IsTrue(((StringProperty)emailContent.Metadata[KnownStringMetadataFields.To]).Value                   == "&lt;friendOfdummy@fake.org&gt;");
        Assert.IsTrue(((DateTimeProperty)emailContent.Metadata[KnownDateTimeMetadataFields.SentDate]).Value.CompareTo(sentDateUtc) == 0);
    }
}</code></pre></div></div></div></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>See Also</h2><div id="seeAlsoSection"><h4>Other Resources</h4><div><a href="https://github.com/dotfurther/OpenDiscoverSDK" target="_blank" rel="noopener noreferrer">OpenDiscoverSDK Samples Repository on GitHub</a></div></div></div><div id="InThisArticleColumn" class="column is-hidden-mobile"><nav class="menu sticky is-hidden"><p class="menu-label"><strong>In This Article</strong></p><ul id="InThisArticleMenu" class="menu-list"><li><a class="quickLink">See Also</a></li></ul></nav></div></div></div><footer id="PageFooter" class="footer border-top py-3 fixedFooter"><div class="columns"><div class="column"><p>Copyright © 2017-2025 dotFurther, inc. All rights reserved.  "Open Discover" is a registered trademark (®) of dotFurther, inc.</p><div class="feedbackLink">Send comments on this topic to
        <a id="HT_MailLink" href="mailto:support%40dotfurther.com?Subject=Open%20Discover®%20SDK%20and%20Platform%20for%20.NET%20-%20Release%202025.4.2">support@dotfurther.com</a></div>
        <script type="text/javascript">
        var HT_mailLink = document.getElementById("HT_MailLink");
        HT_mailLink.href += ": " + document.title + "\u0026body=" + encodeURIComponent("Your feedback is used to improve the documentation and the product. Your e-mail address will not be used for any other purpose and is disposed of after the issue you report is resolved. While working to resolve the issue that you report, you may be contacted via e-mail to get further details or clarification on the feedback you sent. After the issue you report has been addressed, you may receive an e-mail to let you know that your feedback has been addressed.");
        </script> 
				</div><div class="column"> 
				</div></div></footer></div><script>$(function(){
SetDefaultLanguage("cs");
LoadTocFile(null, null);
InitializeQuickLinks();

$(".toggleSection" ).click(function () {
    SectionExpandCollapse(this);
});

$(".toggleSection").keypress(function () {
    SectionExpandCollapseCheckKey(this, event)
});
hljs.highlightAll();
});</script></body></html>